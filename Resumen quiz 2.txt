
------------------- ACID -----------------------------------------------------

* Es lo básico que debe tener una DB relaional para poder ser consistente
	- Atomicity: Transacciones completas, (todo o nada)
	- Consistency:Veracidad de los datos, datos válidos deacuerdo a las 
	  reglas definidas (fechas, montos de dinero....)
	- Isolation: Independencia de las transacciones, una transacción no debe 
	   afectar la otra.
	- Durability: Durabilidad o preservación de los datos durante mucho tiempo,
	  historial de los datos.

------------------ NOMING CONVENTIONS --------------------------------------

	- Eliminar las comillas, en minúsulas y más de dos palabras separadas por un guión bajo
	- Evitar las palabras reservadas, sin abrebiaciones, los tipos de datos no son nombre
	- Las tablas y vistas en plural, PK (id), FK 

------------------ DEPENDENCIA FUNCIONAL -----------------------------------

* Es cuando un campo clave determina a otro campo no clave:
	- A->B: A determina a B ó B es funcionalmente dependiente de A
	- A,B->c: A y B determinan a C ó C es funcionalmente dependiente de A y B
	- DEPENDENCIA PARCIAL: Sólo aplica cuando la clave es compuesta(dos atributos como PK),
	  es cuando parte de la clave determina un campo no clave
	- DEPENDENCIA TRANCITIVA: Es cuando un campo no clave determina a otro campo no clave

------------------ NORMALIZACIÓN --------------------------------------------

* Es la aplicación de un conjunto de reglas o normas a cada una de las entidades de una
  DB con el objetivo de minimizar la redundancia de datos, facilitando así la posterior 
  gestión y utilización de una DB. 
	a) Ayuda a eliminar las anomalias de inserción, actualización y eliminación en una DB
	b) Reduce el espacio necesario para describir sus datos
	c) Entre más se normalice, aumenta el uso de inner joins y proteje la integridad de 
	   los datos
	d) La desnormalización se utiliza para crear sistemas altamente escalables

	- 1NF: + Requiere que los datos sean atómicos, prohibe que un campo tenga más de un dato
                 de su dominio de columna, no datos diferentes en un campo separados por comas y giones.
	       + Exige que todas las entidades o tablas deben tener una PK.
	       + Indica que una tabla no debe tener atributos que acepten valores nulos  
	- 2NF: + Ya debe de estar en la 1FN
	       + Se debe ELIMINAR LA DEPENDENCIA PARCIAL (segun las claves PK, se dividen en dos o
		 más tablas para que cada atributo no primo o no clave dependa sólamente de su campo clave
		 y no olvidar la clave foránea).
	       + Los campos claves van señalados ó sub rayados
	- 3NF: + Debe de estar en la 1FN Y 2FN
	       + Ningun campo o atributo no clave debe depender de otro no clave (ELIMINAR DEPENDENCIA 
                 TRANCITIVA).
	- BOYCE-CODD NF: + Es la 3.5 NF, toda tabla que esta en la 3.5NF ya esta en la 3NF, pero nó
                           necesariamente la que esté en 3NF ya cumpla con la (BCNF), 
        - 4NF:  + Debe de estar en la 3NF 
	        + Varias relaciones de muchos a muchos pero no unidas entre si
		+ Un registro no debe de tener dos o más valores múltiples independientes sobre una entidad
		+ Eliminar dependencias de valores múltiples (un elemento depende de más de un valor)
	- 5NF:  + Debe de estar en la 4NF
		+ Remover las dependencias de joins, varias relaciones de muchos a muchos unidos.
	        + Sun contenido de información no debe reconstruirce apartir de varios tipos de registros 
		  más pequeños
 
* NOTA: Se puede saltar la 2NF dependiendo de cómo se seleccionen las claves (en algunos casos en la 3NF 
        se llega a la 2NF)

------------------- TABLESPACES ---------------------------------------------------

* Es una estructura lógica primaria de almacenamiento de una base de datos para almacenar los 
  ficheros (datafiles). Cada tablespace debe de tener 1 o varios Datafiles donde se almacena  
  toda la información y los datafiles deben de tener una estructura lógica
	 
	- Tablespaces -> Lógicos NO SE PUEDE CREAR UN TABLESPACE SIN UN DATAFILE
	- CUANDO SE CREA UN USUARIO SE LE DEBE INDICAR A QUE TABLESPACE SE VA A ALMACENAR, 
          SI NO SE GUARDA POR DEFECTO EN USERS.
	- El tablespace es el que contiene la información necesaria de los usuarios (SYS y SYSTEM) que son 
	  los usuarios que tienen la información necesaria para que funcione la DB.
        - Cuando se crea una DB se debe de crear almenos un tablespace, que por defecto es SYSTEM
	- Se recomienda almenos crear otro tablespace para almacenar el resto de usuarios que vayamos creando
	  en nuestra DB.
	- Cuando se crea un tablespace se debe al menos indicar un datafile
	- Sí elimino sólo el Tablespace su datafile queda, no se borra

	- Datafiles -> Físicos: RUTA FÍSICA DEL DISCO DURO, QUE TANTO TAMAÑO TIENE FÍSICA/ LA DB, LOS OBJETOS 
				SE CREAN DENTRO DE LOS DATAFILES.
	  fichero físico al que se le asigna un directorio (ruta), un nombre y un 
	  tamaño inicial al que posteriormente podremos modificar (segun las necesidades y las restricciones 
	  de la instalación.
	- NOTA: + El tamaño de un TABLESPACE es el tamaño de los DATAFILES.
		+ El tamaño de la base de datos es el tamaño colectivo de los TABLESPACE

* Tipos de tablespaces:
	- Bigfile: Los bloques estan alterados para almacenar más información, (SÓLO PUEDE TENER 1 datafile)
	- System: Es donde se encuantra toda la información de Oracle para poder funcionar (pribiligios), 
	          siempre va a estar corriendo, se crea automáticamente cuando se instala el Oracle.
	- Sysaux: Auxiliar de System, se crea y se actualiza cuando se crea y actualiza la DB, 
		  nó extraible ni desechable.
	- UNDO: Almacena la información eliminada, (reversión, recuperación de transacciones de las DB, 
		recuperación de los daños lógicos). Nó es posible crear tablas ó índices, cambio de operaciones
	        DNL en transacciones,a cada instancia de oracle se le asigna sólo un espacio de tabla para deshacer.
	- Read-only tablespace: Elimina la necesidad de realizar copias de seguridad y recuperación, 
		                porciones grandes y estáticas de una DB, no se puede modificar, si recupera 
				una base de datos no es necesario tablespaces de sólo lectura.
	- Tempory: Los datos persisten sólo durante la sesión, mejora la concurrencia de operaciones múltiples,
		   evita las operaciones de gestión de espacios, las ganancias de rendimiento son significativos
		   con real aplicación CLÚSTERS. 

* Comandos tablespace y datafile:
	- select *from dba_tablespaces; (listar ó mostrar todos los Tablespaces)
        - select *from dba_data_files;  (listar ó mostar todos los Datafiles)
	- SELECT *FROM user_users;      (Usuario SYSTEM) 
	- create tablespace TEST datafile '/users/oradata/orcl/test01.dbf' size 100M; (Crear un tablespace TEST, 
	  de 100MB, en el directorio /users/oradata/orcl:)
	- Alter tablespace nombre_tablespace add datafile '/users/oracle/orcl/nombre_datafile2.dbf' size 100M; 
	 (añadiendo un datafile a un Tablespace existente)
	- alter datafile '/users/oradata/orcl/test01.dbf' resize 150M; (aumentar tamaño del datafile existente)
	- drop tablespace TEST; (borrar sólo el tablespace)
	- drop tablespace nombre del tablespace including contents and datafiles; (elimina el tablespace con sus datafiles)
	- ALTER DATABASE DATAFILES nombre_datafile AUTOEXTEND ON NEXT 20M MAXSIZE 1000M; (aumenta el tamaño de la base de 
	  datos aumentando dinámicamente sus datafiles en sus Tablespace existentes, aumenta de 20 en 20 hasta max 1000)

------------------ ADMINISTRACIÓN DE USUARIOS Y PRIBILEGIOS ------------------------------------------

* CONCEPTOS:
	*- Usuario: Objeto que se puede conectar a la DB, se crea por medio de un usuario y contraseña y se define a que 
	           tablespace está asociado.
	- Rol: Es un grupo de privilegios que se le asignan a un usuario o grupo de usuarios que realizan la misma función
	       o a otros roles.
	- Privilegios: Es el permiso ó permisos que se le dan a un usuario para que interactue con la DB, (crear, sólo lectura,
                       modificar,etc...)
	- NOTA: El que crea un obj automáticamente tiene los privilegios para admin ése obj, o el usuario SYSTEM, o otro usuario
		con los privilegios asignados, si un user quiere ver o admin ése obj, se le deben dar los privilegios.
	*- Perfiles: Es el límite de recursos que un user puede tener en una DB-
	   - Recursos: Cómo se comporta el user durante la sesión en el sistema, (tiempo de conexión, # de equivocaciones del password, 
		       tiempo para cambiar password, # CPU que puede utilizar el user).
	- NOTA: Un user puede nó tener un perfil o máximo 1 perfil (0-1), dentro de un perfil debe de tener mínimo un recurso configurado
                ó muchos recursos (1-N).

* COMANDOS: (Privilegios, Rol, usuarios, Perfiles)
	- Privilegios: GRANT -> Garantizar
		       REVOKE -> Quitar

	- Rol: (CREATE,ALTER,DROP,SET) ROLE
	       (GRANT,REVOKE) TO-name_OF_oracle

	- Usuario: (CREATE,ALTER,DROP) USER
		   (GRANT,REVOKE) TO_NAME_OF_USER

	- Perfil: (CREATE,ALTER,DROP) USER
		  ALTER USER.....PROFILE
		  CREATE USER.....PROFILE

* COMANDOS: (Creación y manipulación de usuarios)

    - CREACIÓN DE USUARIO-FORMA LARGA: 1. CREATE USER Sidney
					2. IDENTIFIED BY contraseña
					3. DEFAULT TABLESPACE example
					4. QUOTA 10M ON exampe
					5. TEMPORARY TABLESPACE temp
					6. QUOTA 5M ON System
					7. PROFILE app_user
					8. PASSWORD EXPIRE;
	 NOTA: las líneas 3 y 4 se pueden eliminar si sólo se quiere crear un usuario
	       de sólo lectura y se puede manejar el acceso por medio de los privilegios.

    - CREACIÓN DE USUARIO-FORMA RESUMIDA: 1. CREATE USER Sidney
					  2. IDENTIFIED BY contraseña
					  3. DEFAULT TABLESPACE example
					  4. QUOTA ON 10M ON exampe

    - MODIFICACIÓN DE USUARIO: 1. ALTER USER Sidney (PROFILE....ETC)
					2. IDENTIFIED BY contraseña
					3. [DEFAULT TABLESPACE example]
					4. [TEMPORARY TABLESPACE temp]		
					5. [QUOTA 10M UNLIMITED ON example]
					6. [PASSWORD EXPIRE]
					7. [ACCOUNT {LOCK|UNLOCK}]
					8. [PROFILE perfil];
	
    - ELIMINACIÓN DE USUARIO: 1. DROP USER nombre usuario [CASCADE];
		+ NOTA: - Si queremos eliminar un usuario con [CASCADE] que a creado uno o varios objetos 
			  (tablas), automáticamente se eliminaran todos los objs hijos de este usuario
			- Se puede solucionar eliminando el privilegio de crear sesión
			- Otra solución es trasladar todos los objs a otro DBA, lo cual genera muchisimo trabajo
			- Otra solución es crear varios DBA y compartir la misma contraseña para todos.
			  (NÓ RECOMENDABLE PARA AUDITORÍAS)
   	
     - MANIPULACIÓN DE PRIVILEGIOS A USUARIOS: 
		1. GRANT CREATE SESSION, CREATE TABLE TO aitor; 	
		   (al usuario aitor le damos o garantizamos el privilegio de crear sesión y crear taba)
	        2. GRANT CREATE PROCEDURE, EXECUTE ANY PROCEDURE TO aitor, luisa; 
		   (se le da el privilegio de crear procesos, ejecutar cualquier proceso a los usuarios aitor y luisa)
		3. GRANT CREATE USER TO luisa WITH ADMIN OPTIONS; 
		   (le damos el privilegio de creación de usuario a luisa con obciones administrativas)
		4. GRANT DBA TO nombre del usuario;
		   (le damos un Rol de DBA al usuario x)
    
      - MANIPULACIÓN DE PRIVILEGIOS A OBJETOS: SE UTILISA LA PALABRA (ON) PARA ESPECIFICAR A QUE OBJETO SE REFIERE
		1. GRANT SELECT ON juan.empleados TO aitor;
		   (se le concede hacer SELECT al usuario aitor, sobre la tabla empleados donde el dueño es juan)
		2. GRANT UPDATE ANY TABLE TO aitor;
		   (se le concede hacer UPDATE al usuario aitor en cualquier tabla)
		3. GRANT SELECT, INSERT, UPDATE ON luisa.farmacia TO public;
		   (se le concede SELECT, INSERT, UPDATE la Rol public en la tabla farmacia de la cual es dueña luisa,
		    significa que todos los usuarios del sistema y los que yó cree, tendran esos privilegios)
		4. GRANT INSERT (id,apellidos) ON juan.empleados TO luisa;
		   (se le concede hacer inserciones en las propiedades (id y apellidos) al usuario luisa en la tabla 
		   empleados donde el dueño es juan)

	* NOTA: PRIVILEGIOS SOBRE LOS OBJETOS (Tablas, Vistas,Secuencia, Prosedimiento)

		- T: ALTER, UBDATE, DELETE, INSERT, SELECT
		- V: DELETE, INSERET, SELECT
		- S: ALTER, SELECT
		- P: EXECUTE 

   	* Rol público: Lo recomendado por Oracle es que no se den permisos sobre éste Rol ya que no se puede depender
		       los ususarios sobre éste Rol ya que si en versiones futuras eliminan éste rol o le quitan privilegios
		       se pueden alterar esos roles que vienen por defecto en el sistema.

		      - select table_name, privilege FROM sys.dba_tab_privs WHERE grantee='PUBLIC';

	- ELIMINACIÓN DE PRIVILEGIOS: Se debe tener en cuenta que si se eliminan privilegios a un dueño de un o unos objetos
				      a los cuales se les haya dado el mismo privilegio, automáticamente se elimina ése 
				      privilegio a los objetos hijos.
				     
				      1. REVOKE permiso1,permiso2,.... ó ALL [PRIVILEGES]
				      2. ON [usuario.]objeto
				      3. FROM nombreUsuario |rol| PUBLIC [,nombreUsuario] | nombreRol,....];
				      4.
				      5. REVOKE INSERT on employees FROM luisa; -- esta línea dice que se le quita el privilegio 
										   de insertar al Usuario luisa sobre la tabla empleados.

	- ROLES: Recordar que los roles se pueden anidar para así poder administrar los diferentes roles sobre los usuarios
	       
		- creación de roles: 1. CREATE ROLE nombreRol
				     2. [IDENTIFIED BY contraseña]; 

		- borrar role: 1. DROP ROLE nombreRol;

		- dar permisos a roles: 1. GRANT permiso1[permiso2,...];
					2. ON [usuario.]objeto
					3. TO nombreRole;

		- Ejemplos: 1. GRANT SELECT, UPDATE ON scott.emp TO miRole;
			    2. GRANT SELECT, INSERT, DELETE, UPDATE ON scott.dept TO miRole;
			    3. GRANT SELECT ON scott.salgrade TO miRole;
			    4. GRANT SELECT ON scott.bonus TO miRole;

	 * ROLES ESPECÍFICOS:
          
	   - dba_roles: Contiene todos los roles disponibles
 	     select *from dba_roles; (con el usuario sysem me muestra todos los roles disponibles)
		
	   - dba_role_privs: Contiene el mapeado deroles y usuarios
             -- contiene el mapeado de Roles Y usuarios
             select¨* from dba_roles_privs where grantee = "AMARTINEZ"

	   - dba_sys_privs: Privilegios asignados a cada role (incluso a los ya predefinidos Oracle)
	     -- privilegios asignados a cada role
	     select * from dba_sys_privs where grantee = "DBA";

	   - ROLE_TAB_PRIVS: Privilegios de tablas garantizados a roles.
	     -- privilegios de tablas garantizados a roles
		select *from ROLE_TAB_PRIVS;

	   - ROLE_SYS_PRIVS: Privilegios del sistema asignados a roles
	    -- privilegios del sistema asignados a roles
	       select *from ROLE_SYS_PRIVS;
		
	   - ROLES QUE SE HAN ASIGNADOS A OTROS ROLES
             select *from ROLE_ROLE_PRIVS; 

	   - LÍMITES DE USO DE ESOACIOS EN DISCO
	     select *from dba_ts_quotas;

	   - LÍMITES DE RECURSOS EN ORACLE PARA EL USUARIO ACTUAL
	     select *from user_resource_limits;

	   - VISTA QUE APUNTA REALMENTE A LA TABLA SYS.USERS. ALMACENA INFO DE TODOS LOS USUARIOS DE LA BD
	     select *from dba_users;

	    - VISTA QUE MUESTRA INFORMACIÓN SOBRE EL USUARIO ACTUALMENTE CONECTADO
	      select *from user_users;

	   - CONTIENE TODAS LAS TABLAS ACCESIBLES POR EL USUARIO (las compias más las que tienen permisos sobre ellas)
	     select +from all_tables,

	   - CONSULTAMOS TODOS LOS PRIVILEGIOS QUE CONTIENE EL ROL DBA
	     select *from dba_sys_privs_where grantee= "DBA";	
	
	* Perfiles: Si el usuario no tiene perfil asignado, se le asigna automáticamente el perfil de DEFAULT
                    1. SELECT *FROM DBA_PROFILES ORDER BY PROFILE;
		    2. SELECT USERNAME, PROFILE, ACCOUNT_STATUS FROM DBA_USERS;

                  - SELECT *FROM DBA_PROFILES; (Miramos que perfiles hay creados)
		  - SELECT DISTINCT(PROFILE) FROM DBA_PROFILES; (lista cuantos perfiles tengo)
		  - SELECT *FROM DBA_PROFILES WHERE PROFILE = 'DEFAULT'; (muestra los recursos que tiene asignados este perfil por defecto)
		  - CREATE PROFILE TEST LIMIT IDLE_TIME 5 SESSION_PER_USER 3;( creamos un perfil con limitacion de tiempo de session de 5 y 3 por usuario)

        * NOTA: alterar la sesión en oracle 12c: alter session set "_ORACLE_SCRIPT"= true; 

---------------------------- PRACTICA ADMINISTRACIÓN DE USUARIO ------------------------------

* Desde el usuario System, para esta practica verificamos que usuarios, Tablespace, datafiles y tablas hay creadas; las borramos para iniciar desde cero.

	- Verificamos: + SELECT *FROM DBA_TABLESPACES;
	               + SELECT *FROM DBA_DATA_FILES;
	               + SELECT *FROM DBA_users; 

	- Eliminamos: + alter session set "_ORACLE_SCRIPT"= true; (alteramos sesión cuando nos salga errores de creación o eliminación)
		      + drop tablespace nombre del Tablespace including contents and DATAFILES;
		      + drop table nombre de la tabla;
		      + drop USER NICHE CASCADE; (elimina el usuario y sus objetos y demasb)
		
	- Creación Tablespaces y datafiles: Creamos 2 Tablespaces, cada uno con su datafile, despues creamos dos tablas en cada uno y dos 
                                            usuarios los cuales podran acceder a las tablas así se encuentren en Tablespaces diferentes:
		      0) Alterar la sesión para poder crear usuarios y privilegios 
                         - alter session set "_ORACLE_SCRIPT"= true;

		      1) Creamos los 2 Tablespaces con sus respectivos datafiles
                         - create tablespace Practica_itm datafile 'itm_01.dbf' size 100M;
		         - create tablespace Practica_finance datafile 'finance_01.dbf' size 50M;

		      2) Creación de usuarios con su contraseña, la quota, el Tablespace asignado,
                         y en que Tablespace se le asigna esa cuota.
                         - create user Practica_user1 identified by user1
                           default tablespace Practica_itm quota 50M on Practica_itm; 

		      3) despues de crear el usuario se le debe de dar como mínimo el 
  			 privilegio de crear o iniciar sesión para que se pueda conectar
			 - grant create session to Practica_user1; 

 		      4) creamos un Rol full_access, luego a ése rol full_access le asignamos 
                         todos los privilegios que tiene el rol DBA más el privilegio de crear sesión
                         create role full_access;
  			 - grant dba,create session to full_access; 
			 - REVOKE create session from Practica_user1; -- eliminamos el privilegio anteriormente dado al usuario Practica_user1
			 - grant full_access to Practica_user1; -- le asignamos el rol creado (full_access) al usuario Practica_user1
			 - select *from dba_users WHERE DEFAULT_TABLESPACE IN ('PRACTICA_ITM','PRACTICA_FINANCE');

		      5) Desde los uauarios creados verificamos a que tablas por defecto tenemos acceso.
			 - select *from all_tables; 
			 - select *from user1.nombre del objeto; --(consultamos toda la info de un objeto de otro dueño con el nombre de el que tenga permiso).
                         -select *from all_tables WHERE TABLESPACE_name IN ('PRACTICA_ITM','PRACTICA_FINANCE');

		      6) Creamos las dos tablas una desde su mismo tablespace y otro con el nombre del tablespace donde iría dirigido.
		         - create table employees(
			   id int,
                           first_name varchar(50),   --- tabla con el usuario desde su tablespace
                           last_name varchar(50),
                           email varchar(50),
                           gebder varchar(50)
			    );

			 - create table salaries(
			   id int,
                           employee_id int,   
                           salary decimal(10,2),
                           department varchar(11),
                           beginning_date DATE
			    )
                             tablespace Practica_finance;  --- tabla desde un usuario hacia otro tablespace
  
                          * Consultamos a que tenemos permiso con:- select *from all_tables where tablespace_name in ('practica_itm','practica_finance');

			  *corrección o modificación de algunos usuarios y privilegios:
 				- grant user to user1 quota unlimited on Practica_finance; -- (le asignamos al user1 una cuota ilimitada en el tablespace Practica_finance 
                                                               				       que se olvidó en el momento de la creación del usuario)
 
			  * Desde el dueño(Practica_user1 que es DBA) del objeto 'salaries' le damos permisos al usuario 'Practica_user2' o al Rol en específico: 
				- GRANT SELECT ON salaries TO Practica_user2; -- (sólo vería la tabla o info de los salarios pero sin saber a que empleado pertenece)

				- podemos quItar ese permiso con : REVOKE SELECT ON SALARIES FROM ACCOUNTTANT; 
				   PERO CON EL PERMISO DE LA VISTA read la podemos mirar:  

			  * Desde el dueño(Practica_user1 que es DBA) del objeto 'employees' le damos permisos al usuario 'Practica_user2' para que tenga sólo lectura (read)
			    en una vista del onjeto employes.
				- 1) creamos la vista: 
				     create view employees_details as       --- creación de la vista 
                                     select employees.id,first_name,last_name,email, gender, salary, department,beginning_date from employees
                                     inner join salaries on employees.id = salaries.employees_id
                                     ORDER BY department, salary DESC; 

                                - 2) le damos GRANT READ ON Practica_user1.employeess_detail TO Practica_user2;
            			- GRANT SELECT ON salaries TO Practica_user2;
				- consultamos desde el usuario 'Practica_user2;' con: select *from practica_user1.employees;


			* ALIAS: 

-------------------------------- INPORTAR DATOS -------------------------------------------------------------------------------------------------------

1) desvargamos el archivo donde esten los datos (.CSV...)

2) Creamos la tabla:

create table agencies (
country varchar2(255),
resort_name varchar2(255),
number_of_days integer,
travel_method varchar2(255),
price decimal(10,2),
date_of_issue date,
monht varchar2(255),
holiday_id varchar2(255)
);

3) luego: - Click derecho en la tabla y inportar datos
	  - que si podamos ver los datos cargados en el contenido de archivos, buscamos el archivo donde lo guardamos, tenemos en cuenta el formato(csv), delimiter(,).
	  - Que permita insertar (Metodo de inportación - insert)
	  - pasar todas las columnas a la izquierda para despues pasarlas en el orden en que estan los datos o fue creada la tabla.
	  - Definir lasconcidencias de los nombre de las columnas con las que tenemos, el formato de fecha se puede organizar segun la nesecidad (MM/DD/YY).
          - Por ultimo verificar la tabla que si se cargaron los datos (select *from agencies;)

------------------------------ VISTAS Y VISTAS MATERIALIZADAS ------------------------------------------------------------------------------------------------------

Una vista es como una tabla lógica, es una tabla que existe virtualmente pero físicamente no existe dentro de la DB, una vista no tiene datos y cuando se contruye 
la vista la información que viene de las tablas se llama tabla base. La vista es un alias a un query y ése alias se convierte como si fuese una tabla más pero lógica, 
es una tabla que no existe. ejm:

* Creación básica de una vista: - CREATE VIEW customer_credit AS SELECT name, credit_limit FROM customers; -- (creamos la vista customer_credit y traemos las columnas
													       name y credit_limit de la tabla customers)
				- SELECT *FROM customer_credits; ---(consultamos) 

* NOTA: Para crear una vista se debe tener el privilegio de CREATE VIEW, y si se quiere crearle la vista a otro usuario se requiere el privilegio de CREATE ANY VIEW.
        Si se quiere crear un alias de un query complejo, se debe tener los privilegios nesesarios sobre las tablas involucradas en el query (insert,update,delete).
	Es inportante saber que si yó sólo voy a consultar la vista que otro usuario creó, yo sólo debo de tener los permisos de lectura o select.
        las vistas sirven para la a) ejecución de querys complejos y verlos como tablas más simples y no  afecta el rendimiento, b) por motivos de seguridad,

* - Si las vistas ya fueron creadas, para no tener que borrarla cambiamos VIEW por OR REPLACE para no tener que eliminar la vista y volverla a crear. 
  - para que sólo se cree la vista cuando las tablas base existan, de lo contrario no se hace.          
  - luego del CREATE VIEW y el nombre de la vista, colocamos la palabra AS y despues se pone la lógica SELECT.

* Las vistas se pueden utilizar para actualizar información pero sólo se pueden cambiar las columnas que esten asociadas a una sola tabla, si la vista tiene 2 iner joins
  no funciona. Ejemplo para actualizar información:

  CREATE VIEW clerk AS
     SELECT employee_id, last_name, department_id, job_id
     FROM EMPLOYEES
     WHERE job_id = 'PU_CLERK'
          or job_id ='SH_CLERK'
          or job_id = 'ST_CLERK';
 
     UPDATE clerk set job_id = 'PU_MAN' WHERE emplyee_id = 118;

- WITH CHECK OPTION: Es algo especial que tenemos en aracle 12c y sirve para tener un mayor control en las vistas cuando se actualizan, sólo permitiria cambiar lo que se encuentra
  dentro del primer where (3), de resto nó.

  CREATE VIEW clerk AS
     SELECT employee_id, last_name, department_id, job_id
     FROM EMPLOYEES
     WHERE job_id = 'PU_CLERK'
          or job_id ='SH_CLERK'
          or job_id = 'ST_CLERK';
     
     WITH CHECK OPTION;

* Ejemplos:
 
 CREATE VIEW EMPLOYEE_VIEW AS
 SELECT LAST _NAME, SALARY*12 ANNUAL_SALARY 
 FROM EMPLOYEES
 WHERE DEPARTMENT_ID =20;

 CREATE OR REPLACE VIEW ACCOUNTS_AVG_BALANCE_GT_50000 AS 
 SELECT ACCOUNTS.TYPE, LOCATIONS.CITY, AVG(BALANCE) FROM ACCOUNTS
 INNER JOIN LOCATIONS ON ACCOUNTS.LOCATIONS_ID = LOCATIONS.ID
 HAVING AVG (BALANCE) >= 50000
 GROUP BY ACCOUNTS.TYPE, LOCATIONS.CITY
 ORDER BY CITY;   

********************  COMANDOS *******************************************

/*CREAR TABLESPACE*/
create tablespace mid_term datafile 'mid_term.DBF' size 20M;

alter session set "_ORACLE_SCRIPT"=true;

/*CREAR PERFIL*/
CREATE PROFILE parcial LIMIT 
IDLE_TIME 20 
FAILED_LOGIN_ATTEMPTS 2;

/*CREAR USUARIO*/
CREATE USER LGIRALDO
IDENTIFIED BY lgiraldo12
DEFAULT TABLESPACE mid_term
QUOTA UNLIMITED ON mid_term;

/*ASIGNAR PERFIL A USUARIO*/
alter user LGIRALDO profile parcial;

/*CREAR USUARIO SIN ESPACIO EN TABLESPACE*/
CREATE USER USUARIO2
IDENTIFIED BY lgiraldo12
DEFAULT TABLESPACE mid_term;

/*CREAR ROLES*/
CREATE ROLE MINI_DBA;
CREATE ROLE STUDENT;

/*ASIGNAR PERMISOS AL ROL CREADO*/
GRANT  CREATE TABLE, CREATE VIEW, CREATE SESSION TO MINI_DBA;
GRANT CREATE SESSION, SELECT ANY TABLE TO STUDENT;

/*ASIGNAR ROL A USUARIO*/
GRANT MINI_DBA TO LGIRALDO;



--------------------------------------------------------
-- Archivo creado  - jueves-octubre-17-2019   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for Table BARRIOS
--------------------------------------------------------

  CREATE TABLE "LGIRALDO"."BARRIOS" 
   (	"ID" NUMBER(22,0), 
	"NOMBRE" VARCHAR2(255 BYTE), 
	"COMUNA_ID" NUMBER(22,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Table COMUNAS
--------------------------------------------------------

  CREATE TABLE "LGIRALDO"."COMUNAS" 
   (	"ID" NUMBER(22,0), 
	"NOMBRE" VARCHAR2(255 BYTE), 
	"TIPO_COMUNA_ID" NUMBER(22,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Table ESTADOS_PRESTADORES
--------------------------------------------------------

  CREATE TABLE "LGIRALDO"."ESTADOS_PRESTADORES" 
   (	"ID" NUMBER(22,0), 
	"NOMBRE" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Table MODALIDADES
--------------------------------------------------------

  CREATE TABLE "LGIRALDO"."MODALIDADES" 
   (	"ID" NUMBER(22,0), 
	"NOMBRE" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Table PRESTADORES
--------------------------------------------------------

  CREATE TABLE "LGIRALDO"."PRESTADORES" 
   (	"ID" NUMBER(22,0), 
	"NOMBRE" VARCHAR2(255 BYTE), 
	"FECHA_CONTRATACION" DATE, 
	"VALOR_CONTRATO" NUMBER(22,0), 
	"ESTADO_ID" NUMBER(22,0)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Table SEDES
--------------------------------------------------------

  CREATE TABLE "LGIRALDO"."SEDES" 
   (	"ID" NUMBER(22,0), 
	"SEDE" VARCHAR2(255 BYTE), 
	"TELEFONO" VARCHAR2(255 BYTE), 
	"DIRECCION" VARCHAR2(255 BYTE), 
	"CUPOS_DISPUESTOS" NUMBER(22,0), 
	"BARRIO_ID" NUMBER(22,0), 
	"MODALIDAD_ID" NUMBER(22,0), 
	"PRESTADOR_ID" NUMBER(22,0)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Table TIPO_COMUNAS
--------------------------------------------------------

  CREATE TABLE "LGIRALDO"."TIPO_COMUNAS" 
   (	"ID" NUMBER(22,0), 
	"TIPO" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Index ID_SEDES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "LGIRALDO"."ID_SEDES_PK" ON "LGIRALDO"."SEDES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Index ID_BARRIOS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "LGIRALDO"."ID_BARRIOS_PK" ON "LGIRALDO"."BARRIOS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Index ID_TIPO_COMUNAS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "LGIRALDO"."ID_TIPO_COMUNAS_PK" ON "LGIRALDO"."TIPO_COMUNAS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Index ID_COMUNAS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "LGIRALDO"."ID_COMUNAS_PK" ON "LGIRALDO"."COMUNAS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Index ID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "LGIRALDO"."ID_PK" ON "LGIRALDO"."ESTADOS_PRESTADORES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Index ID_MOD_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "LGIRALDO"."ID_MOD_PK" ON "LGIRALDO"."MODALIDADES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  DDL for Index ID_PRESTADORES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "LGIRALDO"."ID_PRESTADORES_PK" ON "LGIRALDO"."PRESTADORES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "MID_TERM" ;
--------------------------------------------------------
--  Constraints for Table SEDES
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."SEDES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."SEDES" MODIFY ("SEDE" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."SEDES" MODIFY ("TELEFONO" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."SEDES" MODIFY ("DIRECCION" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."SEDES" MODIFY ("CUPOS_DISPUESTOS" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."SEDES" MODIFY ("BARRIO_ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."SEDES" MODIFY ("MODALIDAD_ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."SEDES" MODIFY ("PRESTADOR_ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."SEDES" ADD CONSTRAINT "ID_SEDES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "MID_TERM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table MODALIDADES
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."MODALIDADES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."MODALIDADES" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."MODALIDADES" ADD CONSTRAINT "ID_MOD_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "MID_TERM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table COMUNAS
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."COMUNAS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."COMUNAS" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."COMUNAS" MODIFY ("TIPO_COMUNA_ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."COMUNAS" ADD CONSTRAINT "ID_COMUNAS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ESTADOS_PRESTADORES
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."ESTADOS_PRESTADORES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."ESTADOS_PRESTADORES" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."ESTADOS_PRESTADORES" ADD CONSTRAINT "ID_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table PRESTADORES
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."PRESTADORES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."PRESTADORES" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."PRESTADORES" MODIFY ("FECHA_CONTRATACION" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."PRESTADORES" MODIFY ("VALOR_CONTRATO" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."PRESTADORES" MODIFY ("ESTADO_ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."PRESTADORES" ADD CONSTRAINT "ID_PRESTADORES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "MID_TERM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BARRIOS
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."BARRIOS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."BARRIOS" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."BARRIOS" MODIFY ("COMUNA_ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."BARRIOS" ADD CONSTRAINT "ID_BARRIOS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TIPO_COMUNAS
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."TIPO_COMUNAS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."TIPO_COMUNAS" MODIFY ("TIPO" NOT NULL ENABLE);
  ALTER TABLE "LGIRALDO"."TIPO_COMUNAS" ADD CONSTRAINT "ID_TIPO_COMUNAS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "MID_TERM"  ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table BARRIOS
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."BARRIOS" ADD CONSTRAINT "COMUNA_ID_FK" FOREIGN KEY ("COMUNA_ID")
	  REFERENCES "LGIRALDO"."COMUNAS" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table COMUNAS
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."COMUNAS" ADD CONSTRAINT "TIPO_COMUNA_ID_FK" FOREIGN KEY ("TIPO_COMUNA_ID")
	  REFERENCES "LGIRALDO"."TIPO_COMUNAS" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table PRESTADORES
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."PRESTADORES" ADD CONSTRAINT "ESTADO_ID_FK" FOREIGN KEY ("ESTADO_ID")
	  REFERENCES "LGIRALDO"."ESTADOS_PRESTADORES" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEDES
--------------------------------------------------------

  ALTER TABLE "LGIRALDO"."SEDES" ADD CONSTRAINT "BARRIO_ID_FK" FOREIGN KEY ("BARRIO_ID")
	  REFERENCES "LGIRALDO"."BARRIOS" ("ID") ENABLE;
  ALTER TABLE "LGIRALDO"."SEDES" ADD CONSTRAINT "MODALIDAD_ID_FK" FOREIGN KEY ("MODALIDAD_ID")
	  REFERENCES "LGIRALDO"."MODALIDADES" ("ID") ENABLE;
  ALTER TABLE "LGIRALDO"."SEDES" ADD CONSTRAINT "PRESTADOR_ID_FK" FOREIGN KEY ("PRESTADOR_ID")
	  REFERENCES "LGIRALDO"."PRESTADORES" ("ID") ENABLE;


******************************************************************

CREATE TABLE ESTADOS_PRESTADORES (
  ID NUMBER (22,0) NOT NULL,
  NOMBRE VARCHAR(255) NOT NULL
  );
  
  ALTER TABLE ESTADOS_PRESTADORES
  ADD CONSTRAINT ID_PK PRIMARY KEY (ID);

CREATE TABLE MODALIDADES (
  ID NUMBER (22,0) NOT NULL,
  NOMBRE VARCHAR(255) NOT NULL,
    CONSTRAINT ID_MOD_PK PRIMARY KEY (ID)
);

CREATE TABLE TIPO_COMUNAS (
  ID NUMBER (22,0) NOT NULL,
  TIPO VARCHAR(255) NOT NULL,
    CONSTRAINT ID_TIPO_COMUNAS_PK PRIMARY KEY (ID)
);

CREATE TABLE COMUNAS (
  ID NUMBER (22,0) NOT NULL,
  NOMBRE VARCHAR(255) NOT NULL,
  TIPO_COMUNA_ID NUMBER (22,0) NOT NULL,
    CONSTRAINT ID_COMUNAS_PK PRIMARY KEY (ID),
    CONSTRAINT TIPO_COMUNA_ID_FK FOREIGN KEY (TIPO_COMUNA_ID)
    REFERENCES TIPO_COMUNAS(ID)
);

CREATE TABLE BARRIOS(
  ID NUMBER (22,0) NOT NULL,
  NOMBRE VARCHAR(255) NOT NULL,
  COMUNA_ID NUMBER (22,0) NOT NULL,
    CONSTRAINT ID_BARRIOS_PK PRIMARY KEY (ID),
    CONSTRAINT COMUNA_ID_FK FOREIGN KEY (COMUNA_ID)
    REFERENCES COMUNAS(ID)
);

CREATE TABLE PRESTADORES(
  ID NUMBER (22,0) NOT NULL,
  NOMBRE VARCHAR(255) NOT NULL,
  FECHA_CONTRATACION DATE NOT NULL,
  VALOR_CONTRATO NUMBER (22,0) NOT NULL,
  ESTADO_ID NUMBER (22,0) NOT NULL,
    CONSTRAINT ID_PRESTADORES_PK PRIMARY KEY (ID),
    CONSTRAINT ESTADO_ID_FK FOREIGN KEY (ESTADO_ID)
    REFERENCES ESTADOS_PRESTADORES(ID)
);

CREATE TABLE SEDES(
  ID NUMBER (22,0) NOT NULL,
  SEDE VARCHAR(255) NOT NULL,
  TELEFONO VARCHAR(255) NOT NULL,
  DIRECCION VARCHAR(255) NOT NULL,
  CUPOS_DISPUESTOS NUMBER (22,0) NOT NULL,
  BARRIO_ID NUMBER (22,0) NOT NULL,
  MODALIDAD_ID NUMBER (22,0) NOT NULL,
  PRESTADOR_ID NUMBER (22,0) NOT NULL,
    CONSTRAINT ID_SEDES_PK PRIMARY KEY (ID),
    CONSTRAINT BARRIO_ID_FK FOREIGN KEY (BARRIO_ID)
    REFERENCES BARRIOS(ID),
    CONSTRAINT MODALIDAD_ID_FK FOREIGN KEY (MODALIDAD_ID)
    REFERENCES MODALIDADES(ID),
    CONSTRAINT PRESTADOR_ID_FK FOREIGN KEY (PRESTADOR_ID)
    REFERENCES PRESTADORES(ID)  
);

SELECT * FROM BARRIOS;

/*CREAR VISTAS*/
CREATE VIEW QUERY_1
 AS (SELECT NOMBRE)
 FROM PRESTADORES 
 WHERE NOMBRE.MODALIDAD = ludotekas;



  
  

 	            




		      	
		      
 	

	


	
	   
        
	

	  